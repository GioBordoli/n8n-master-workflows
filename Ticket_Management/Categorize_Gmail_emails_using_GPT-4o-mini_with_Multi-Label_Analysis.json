{
  "meta": {
    "instanceId": "e79711d9b5f95256b3a86fdcb99d54e393eee93529e5d236130c963130fb816a",
    "templateId": "5727"
  },
  "name": "Categorize Gmail emails using GPT-4o-mini with Multi-Label Analysis",
  "tags": [],
  "nodes": [
    {
      "id": "gmail-trigger",
      "name": "Gmail Trigger",
      "type": "n8n-nodes-base.gmailTrigger",
      "position": [
        460,
        420
      ],
      "parameters": {
        "simple": false,
        "filters": {},
        "options": {},
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        }
      },
      "typeVersion": 1
    },
    {
      "id": "get-gmail-labels",
      "name": "Get Gmail Labels",
      "type": "n8n-nodes-base.gmail",
      "position": [
        680,
        420
      ],
      "webhookId": "9c24468a-cf62-4cdd-bc64-eb92b9548b29",
      "parameters": {
        "resource": "label",
        "returnAll": true
      },
      "typeVersion": 2.1
    },
    {
      "id": "get-email-content",
      "name": "Get Email Content",
      "type": "n8n-nodes-base.gmail",
      "position": [
        880,
        420
      ],
      "webhookId": "2942d960-47df-417f-b3d9-d7b6c565ea92",
      "parameters": {
        "simple": false,
        "options": {},
        "messageId": "={{ $('Gmail Trigger').first().json.id }}",
        "operation": "get"
      },
      "typeVersion": 2.1
    },
    {
      "id": "prepare-prompt",
      "name": "Prepare Prompt",
      "type": "n8n-nodes-base.code",
      "position": [
        1100,
        420
      ],
      "parameters": {
        "jsCode": "// R√©cup√®re l'email et les labels\nconst emailData = $('Get Email Content').first().json;\nconst allLabels = $('Get Gmail Labels').all().map(item => item.json);\n\n// Filtre les labels syst√®me\nconst systemLabels = ['INBOX', 'SENT', 'DRAFT', 'SPAM', 'TRASH', 'IMPORTANT', 'STARRED'];\nconst userLabels = allLabels.filter(label => \n  !systemLabels.includes(label.name.toUpperCase())\n);\n\n// Cr√©er la liste des labels format√©e\nconst labelsList = userLabels.map(label => `- ${label.name}`).join('\\n');\n\n// Pr√©parer le contenu de l'email\nconst emailContent = emailData.text || emailData.body || emailData.snippet || 'Pas de contenu disponible';\n\n// Cr√©er le prompt final MULTI-LABELS\nconst prompt = `Analyse cet email et choisis les MEILLEURS LABELS (1 √† 3 maximum) parmi ceux disponibles :\n\nEMAIL √Ä ANALYSER :\nDe: ${emailData.from}\nObjet: ${emailData.subject}\nContenu: ${emailContent}\n\nLABELS DISPONIBLES :\n${labelsList}\n\nINSTRUCTIONS :\n1. Analyse le contenu et le contexte de l'email\n2. Choisis entre 1 et 3 labels les PLUS APPROPRI√âS parmi la liste\n3. Privil√©gie la qualit√© √† la quantit√© - si un seul label convient parfaitement, n'en mets qu'un\n4. √âvite les labels syst√®me comme INBOX, SENT, SPAM, etc.\n5. Classe les labels par ordre de pertinence (plus pertinent en premier)\n\nR√©ponds en JSON avec la liste des labels choisis : {\"labels\": [\"label1\", \"label2\", \"label3\"]}`;\n\nconsole.log('üìù Prompt multi-labels cr√©√©:', prompt);\nconsole.log('üè∑Ô∏è Labels disponibles:', userLabels.map(l => l.name));\n\nreturn [{\n  json: {\n    prompt: prompt,\n    email: emailData,\n    labels: allLabels,\n    userLabels: userLabels\n  }\n}];"
      },
      "typeVersion": 2
    },
    {
      "id": "openai-chat-model",
      "name": "OpenAI Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        1340,
        600
      ],
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "typeVersion": 1.2
    },
    {
      "id": "llm-chain",
      "name": "GPT‚Äë4o‚Äëmini Label Analyzer",
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "position": [
        1340,
        420
      ],
      "parameters": {
        "text": "={{ $json.prompt }}",
        "promptType": "define"
      },
      "typeVersion": 1.5
    },
    {
      "id": "find-labels-id",
      "name": "Find Multi-Labels ID",
      "type": "n8n-nodes-base.code",
      "position": [
        1700,
        420
      ],
      "parameters": {
        "jsCode": "// Get LLM Chain response\nconst llmResponse = items[0].json;\n\n// Get labels from Prepare Prompt node\nconst preparePromptData = $('Prepare Prompt').first().json;\nconst allLabels = preparePromptData.labels || [];\n\nconsole.log('ü§ñ LLM Response Raw:', llmResponse);\nconsole.log('üè∑Ô∏è All Labels:', allLabels.map(l => l.name));\n\n// Extract response content (different possible properties)\nlet responseText = '';\nif (llmResponse.text) {\n  responseText = llmResponse.text;\n} else if (llmResponse.response) {\n  responseText = llmResponse.response;\n} else if (llmResponse.output) {\n  responseText = llmResponse.output;\n} else if (typeof llmResponse === 'string') {\n  responseText = llmResponse;\n} else {\n  responseText = JSON.stringify(llmResponse);\n}\n\nconsole.log('üìù Response Text:', responseText);\n\n// Extract label names from response\nlet labelNames = [];\n\n// Try to parse JSON first\ntry {\n  const parsed = JSON.parse(responseText);\n  if (parsed.labels && Array.isArray(parsed.labels)) {\n    labelNames = parsed.labels.map(label => label.trim()).filter(label => label.length > 0);\n  } else if (parsed.label) {\n    // Fallback for old single label format\n    labelNames = [parsed.label.trim()];\n  }\n} catch (e) {\n  // If not JSON, look for pattern {\"labels\": [...]}\n  const jsonMatch = responseText.match(/\\{[^}]*\"labels\"[^}]*\\[([^\\]]+)\\][^}]*\\}/);\n  if (jsonMatch) {\n    const labelsString = jsonMatch[1];\n    labelNames = labelsString.split(',').map(label => \n      label.replace(/[\"']/g, '').trim()\n    ).filter(label => label.length > 0);\n  } else {\n    // Fallback: look for old single label format\n    const singleMatch = responseText.match(/\\{[^}]*\"label\"[^}]*\"([^\"]+)\"[^}]*\\}/);\n    if (singleMatch) {\n      labelNames = [singleMatch[1].trim()];\n    } else {\n      // Last fallback: take first mentioned labels\n      for (const label of allLabels.slice(0, 3)) {\n        if (responseText.toLowerCase().includes(label.name.toLowerCase())) {\n          labelNames.push(label.name);\n        }\n      }\n    }\n  }\n}\n\n// Limit to 3 labels max\nlabelNames = labelNames.slice(0, 3);\n\nconsole.log('üéØ Extracted Label Names:', labelNames);\n\n// Find corresponding labels\nlet selectedLabels = [];\n\nfor (const labelName of labelNames) {\n  // Exact match\n  let foundLabel = allLabels.find(label => \n    label.name.toLowerCase() === labelName.toLowerCase()\n  );\n  \n  // Fallback: partial match\n  if (!foundLabel) {\n    foundLabel = allLabels.find(label => \n      label.name.toLowerCase().includes(labelName.toLowerCase()) ||\n      labelName.toLowerCase().includes(label.name.toLowerCase())\n    );\n  }\n  \n  if (foundLabel && !selectedLabels.find(l => l.id === foundLabel.id)) {\n    // Avoid duplicates\n    selectedLabels.push(foundLabel);\n  }\n}\n\n// If no label found, fallback to first non-system label\nif (selectedLabels.length === 0) {\n  const systemLabels = ['INBOX', 'SENT', 'DRAFT', 'SPAM', 'TRASH', 'IMPORTANT', 'STARRED'];\n  const fallbackLabel = allLabels.find(label => \n    !systemLabels.includes(label.name.toUpperCase())\n  ) || allLabels[0];\n  \n  if (fallbackLabel) {\n    selectedLabels = [fallbackLabel];\n  }\n}\n\nif (selectedLabels.length === 0) {\n  console.error('‚ùå No labels found!');\n  return [{ json: { error: 'No labels found' } }];\n}\n\nconsole.log('‚úÖ Final Selected Labels:', selectedLabels.map(l => `${l.name} (${l.id})`));\n\n// Return label IDs for application\nconst labelIds = selectedLabels.map(label => label.id);\n\nreturn [{\n  json: {\n    labelIds: labelIds,\n    labels: selectedLabels,\n    labelNames: selectedLabels.map(l => l.name),\n    llmResponse: responseText,\n    extractedLabelNames: labelNames,\n    count: selectedLabels.length\n  }\n}];"
      },
      "typeVersion": 2
    },
    {
      "id": "apply-multi-labels",
      "name": "Apply Multi-Labels",
      "type": "n8n-nodes-base.gmail",
      "position": [
        2060,
        420
      ],
      "webhookId": "c260a374-a114-4829-bd16-0b1c009fe7da",
      "parameters": {
        "labelIds": "={{ $json.labelIds }}",
        "messageId": "={{ $('Gmail Trigger').first().json.id }}",
        "operation": "addLabels"
      },
      "typeVersion": 2.1
    },
    {
      "id": "main-sticky-note",
      "name": "üìã USER GUIDE",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        380,
        720
      ],
      "parameters": {
        "width": 650,
        "height": 600,
        "content": "üéØ GMAIL ASSISTANT MULTI-LABELS (1-3 max)\n===========================================\n\nüöÄ HOW TO USE THIS WORKFLOW:\n\n1Ô∏è‚É£ ACTIVATION\n   ‚Ä¢ Click \"Activate\" button in top right\n   ‚Ä¢ Verify Gmail and OpenAI credentials are configured\n   ‚Ä¢ Workflow automatically monitors new emails\n\n2Ô∏è‚É£ AUTOMATIC OPERATION\n   ‚Ä¢ As soon as new email arrives\n   ‚Ä¢ AI analyzes content (sender, subject, body)\n   ‚Ä¢ Smart selection of 1 to 3 relevant labels\n   ‚Ä¢ Automatic label application\n\n3Ô∏è‚É£ ADVANTAGES\n   ‚Ä¢ Only 1 ChatGPT call per email (cost-effective)\n   ‚Ä¢ Up to 3 labels per email (more precise)\n   ‚Ä¢ Automatic adaptation to existing labels\n   ‚Ä¢ No configuration required\n\nüí° BASED ON THE WORKING WORKFLOW\n   Stable and proven version adapted for multi-labels\n\nüéä READY TO USE! Activate and let the magic happen!"
      },
      "typeVersion": 1
    },
    {
      "id": "trigger-sticky",
      "name": "üìß TRIGGER",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        380,
        240
      ],
      "parameters": {
        "color": 2,
        "width": 660,
        "height": 480,
        "content": "üìß EMAIL MONITORING\n‚Ä¢ Checks every minute\n‚Ä¢ Triggers on new emails\n‚Ä¢ Retrieves message ID"
      },
      "typeVersion": 1
    },
    {
      "id": "ai-sticky",
      "name": "ü§ñ AI INTELLIGENCE",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1240,
        240
      ],
      "parameters": {
        "color": 3,
        "width": 430,
        "height": 480,
        "content": "ü§ñ AI MULTI-LABEL ANALYSIS\n‚Ä¢ Optimized prompt for 1-3 labels\n‚Ä¢ Cost-effective GPT-4o-mini\n‚Ä¢ Structured JSON response\n‚Ä¢ Smart contextual analysis"
      },
      "typeVersion": 1
    },
    {
      "id": "processing-sticky",
      "name": "‚öôÔ∏è PROCESSING",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1040,
        240
      ],
      "parameters": {
        "color": 4,
        "width": 200,
        "height": 480,
        "content": "‚öôÔ∏è DATA PREPARATION\n‚Ä¢ Filters system labels\n‚Ä¢ Creates multi-label prompt\n‚Ä¢ Optimizes for AI\n‚Ä¢ Provides full context"
      },
      "typeVersion": 1
    },
    {
      "id": "parsing-sticky",
      "name": "üîß PARSING",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1660,
        240
      ],
      "parameters": {
        "color": 5,
        "width": 260,
        "height": 480,
        "content": "üîß SMART PARSING\n‚Ä¢ Parses JSON arrays [\"label1\", \"label2\"]\n‚Ä¢ Fallback to single label format\n‚Ä¢ Exact + partial matching\n‚Ä¢ Avoids duplicates\n‚Ä¢ Limits to 3 labels max"
      },
      "typeVersion": 1
    },
    {
      "id": "final-sticky",
      "name": "‚úÖ APPLICATION",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1920,
        240
      ],
      "parameters": {
        "color": 6,
        "width": 360,
        "height": 480,
        "content": "‚úÖ FINAL APPLICATION\n‚Ä¢ Applies 1-3 selected labels\n‚Ä¢ Uses labelIds array\n‚Ä¢ Direct modification in Gmail\n‚Ä¢ Automatic confirmation"
      },
      "typeVersion": 1
    },
    {
      "id": "tips-sticky",
      "name": "üí° TIPS",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1040,
        880
      ],
      "parameters": {
        "color": 4,
        "width": 180,
        "height": 200,
        "content": "üí° USAGE TIPS\n‚Ä¢ Test with one email first\n‚Ä¢ Check logs for debugging\n‚Ä¢ Adjust prompt if necessary\n‚Ä¢ Create specific labels before use"
      },
      "typeVersion": 1
    }
  ],
  "active": false,
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "",
  "connections": {
    "LLM Chain": {
      "main": [
        [
          {
            "node": "Find Multi-Labels ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gmail Trigger": {
      "main": [
        [
          {
            "node": "Get Gmail Labels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Prompt": {
      "main": [
        [
          {
            "node": "LLM Chain",
            "type": "main",
            "index": 0
          },
          {
            "node": "GPT‚Äë4o‚Äëmini Label Analyzer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Gmail Labels": {
      "main": [
        [
          {
            "node": "Get Email Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Email Content": {
      "main": [
        [
          {
            "node": "Prepare Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Find Multi-Labels ID": {
      "main": [
        [
          {
            "node": "Apply Multi-Labels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GPT‚Äë4o‚Äëmini Label Analyzer": {
      "main": [
        [
          {
            "node": "Find Multi-Labels ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}